/*
 * Common Security Advisory Framework (CSAF) 2.0 Distribution API
 *
 * This is the OpenAPI definition of the CSAF 2.0 Distribution API v1 designed to be implemented in (trusted) providers
 *
 * API version: 0.1.4
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package router

import (
	"fmt"
	"net/http"
	"net/url"
	"strings"

	"github.com/gorilla/mux"

	"github.com/csaf-poc/csaf_distribution/csaf"
)

func GetByCVE(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	cveEncoded, ok := vars["cve"]
	if !ok {
		reportError(&w, 400, "BAD_REQUEST", "Missing cve parameter")
		return
	}
	cve, err := url.PathUnescape(cveEncoded)
	if err != nil {
		reportError(&w, 500, "UNKOWN", "Unable to URL-unescape cve parameter")
		return
	}

	localCollection := *allDocuments // shallow copy of allDocuments
	tlpPerms := getContextVars(r)
	addTLPFilter(&localCollection, tlpPerms)
	if err := addRegularilyUsedFilters(&localCollection, r); err != nil {
		reportError(&w, 400, "BAD_REQUEST", err.Error())
		localCollection.ClearFilterFuncs()
		return
	}

	query := r.URL.Query()
	cvssv3Param := query.Get("cvssv3")
	cvssv3ParamSplit := strings.Split(cvssv3Param, ",")
	cvssv2Param := query.Get("cvssv2")
	cvssv2ParamSplit := strings.Split(cvssv2Param, ",")

	localCollection.AddFilterFunc(func(doc *csaf.CsafJson) (bool, error) {
		// This filter function is fairly long, as it tries to match CVE-CVSS
		// pairs with are double-nested arrays. Additionaly, a CVSS can be
		// defined twice (v2, v3) and with arithmentic expressions.
		//
		// Performance-wise, this should not be a big problem, as most of the
		// inner loops terminate before finishing full iteration very early.
		for _, vuln := range doc.Vulnerabilities {
			if vuln.Cve != nil && *vuln.Cve == cve {
				// cve matched
				if cvssv3Param != "" || cvssv2Param != "" {
					// any of the params was set
					if vuln.Scores == nil || len(vuln.Scores) == 0 {
						// scores property does not exist, checking not possible
						// do not add the document
						return false, nil
					}
					for _, score := range vuln.Scores {
						if cvssv3Param != "" {
							str := fmt.Sprintf("%f", *score.CvssV3.BaseScore)
							match, err := matchCVSSScore(str, cvssv3ParamSplit...)
							if err != nil {
								// on error, stop and report
								return false, err
							}
							if match {
								// cvssv3 matched
								// add document
								return true, nil
							}
						}
						if cvssv2Param != "" {
							str := fmt.Sprintf("%f", *score.CvssV2.BaseScore)
							match, err := matchCVSSScore(str, cvssv2ParamSplit...)
							if err != nil {
								// on error, stop and report
								return false, err
							}
							if match {
								// cvssv2 matched
								// add document
								return true, nil
							}
						}
					}
					// no specified cvss score matched any document containing
					// the matched cve (otherwise the for-loop would have returned
					// until now)
					// do not add document
					return false, nil
				}
				// no cvss parameter specified, cve matched
				// add document
				return true, nil
			}
			// cve did not match
			// try next vuln object
			continue
		}
		return false, nil
	})

	filtered, err := localCollection.StartFiltering(true)
	if err != nil {
		reportError(&w, 400, "BAD_REQUEST", err.Error())
		localCollection.ClearFilterFuncs()
		return
	}

	withHashes, withSignatures := getWithParameters(r)
	reportSuccess(&w, filtered, withHashes, withSignatures)
}

func GetByID(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	namespaceEncoded, ok := vars["publisher_namespace"]
	if !ok {
		reportError(&w, 400, "BAD_REQUEST", "Missing namespace parameter")
		return
	}
	namespace, err := url.PathUnescape(namespaceEncoded)
	if err != nil {
		reportError(&w, 500, "UNKOWN", "Unable to URL-unescape namespace parameter")
		return
	}
	trackingID, ok := vars["tracking_id"]
	if !ok {
		reportError(&w, 400, "BAD_REQUEST", "Missing tracking ID parameter")
		return
	}

	localCollection := *allDocuments // shallow copy of allDocuments
	tlpPerms := getContextVars(r)
	addTLPFilter(&localCollection, tlpPerms)

	localCollection.AddFilterFunc(func(doc *csaf.CsafJson) (bool, error) {
		return doc.Document.Publisher.Namespace == namespace && doc.Document.Tracking.Id == trackingID, nil
	})

	filtered, err := localCollection.StartFiltering(true)
	if err != nil {
		reportError(&w, 400, "BAD_REQUEST", err.Error())
		localCollection.ClearFilterFuncs()
		return
	}

	withHashes, withSignatures := getWithParameters(r)
	reportSuccess(&w, filtered, withHashes, withSignatures)
}

func GetByPublisher(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	publisherNameEncoded, ok := vars["publisher_name"]
	if !ok {
		reportError(&w, 400, "BAD_REQUEST", "Missing publisher_name parameter")
		return
	}
	publisherName, err := url.PathUnescape(publisherNameEncoded)
	if err != nil {
		reportError(&w, 500, "UNKOWN", "Unable to URL-unescape publisher_name parameter")
		return
	}

	localCollection := *allDocuments // shallow copy of allDocuments
	tlpPerms := getContextVars(r)
	addTLPFilter(&localCollection, tlpPerms)
	if err := addRegularilyUsedFilters(&localCollection, r); err != nil {
		reportError(&w, 400, "BAD_REQUEST", err.Error())
		localCollection.ClearFilterFuncs()
		return
	}

	localCollection.AddFilterFunc(func(doc *csaf.CsafJson) (bool, error) {
		m, err := matchByMatching(doc.Document.Publisher.Name, publisherName, r.URL.Query().Get("matching"))
		//fmt.Printf("Matching '%s' with '%s': %v\n", publisherName, doc.Document.Publisher.Name, m)
		return m, err
	})

	query := r.URL.Query()

	if publisherNamespace := query.Get("publisher_namespace"); publisherNamespace != "" {
		localCollection.AddFilterFunc(func(doc *csaf.CsafJson) (bool, error) {
			fmt.Println(doc.Document.Publisher.Namespace, publisherNamespace)
			return doc.Document.Publisher.Namespace == publisherNamespace, nil
		})
	}

	if publisherCategory := query.Get("publisher_category"); publisherCategory != "" {
		localCollection.AddFilterFunc(func(doc *csaf.CsafJson) (bool, error) {
			return doc.Document.Publisher.Category == csaf.PublisherCategory(publisherCategory), nil
		})
	}

	filtered, err := localCollection.StartFiltering(true)
	if err != nil {
		reportError(&w, 400, "BAD_REQUEST", err.Error())
		localCollection.ClearFilterFuncs()
		return
	}

	withHashes, withSignatures := getWithParameters(r)
	reportSuccess(&w, filtered, withHashes, withSignatures)
}

func GetByTitle(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	titleEncoded, ok := vars["title"]
	if !ok {
		reportError(&w, 400, "BAD_REQUEST", "Missing title parameter")
		return
	}
	title, err := url.PathUnescape(titleEncoded)
	if err != nil {
		reportError(&w, 500, "UNKOWN", "Unable to URL-unescape title parameter")
		return
	}

	localCollection := *allDocuments // shallow copy of allDocuments
	tlpPerms := getContextVars(r)
	addTLPFilter(&localCollection, tlpPerms)
	if err := addRegularilyUsedFilters(&localCollection, r); err != nil {
		reportError(&w, 400, "BAD_REQUEST", err.Error())
		localCollection.ClearFilterFuncs()
		return
	}

	localCollection.AddFilterFunc(func(doc *csaf.CsafJson) (bool, error) {
		return matchByMatching(doc.Document.Title, title, r.URL.Query().Get("matching"))
	})

	filtered, err := localCollection.StartFiltering(true)
	if err != nil {
		reportError(&w, 400, "BAD_REQUEST", err.Error())
		localCollection.ClearFilterFuncs()
		return
	}

	withHashes, withSignatures := getWithParameters(r)
	reportSuccess(&w, filtered, withHashes, withSignatures)
}
