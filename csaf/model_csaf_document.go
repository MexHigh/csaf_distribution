// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package csaf

import "fmt"
import "reflect"
import "encoding/json"

// Contains a list of acknowledgment elements.
type AcknowledgmentsT []struct {
	// Contains the names of entities being recognized.
	Names []string `json:"names,omitempty"`

	// Contains the name of a contributing organization being recognized.
	Organization *string `json:"organization,omitempty"`

	// SHOULD represent any contextual details the document producers wish to make
	// known about the acknowledgment or acknowledged parties.
	Summary *string `json:"summary,omitempty"`

	// Specifies a list of URLs or location of the reference to be acknowledged.
	Urls []string `json:"urls,omitempty"`
}

// Contains branch elements as children of the current element.
type BranchesT []struct {
	// Branches corresponds to the JSON schema field "branches".
	Branches BranchesT `json:"branches,omitempty"`

	// Describes the characteristics of the labeled branch.
	Category BranchesTElemCategory `json:"category"`

	// Contains the canonical descriptor or 'friendly name' of the branch.
	Name string `json:"name"`

	// Product corresponds to the JSON schema field "product".
	Product FullProductNameT `json:"product,omitempty"`
}

type BranchesTElemCategory string

const BranchesTElemCategoryArchitecture BranchesTElemCategory = "architecture"
const BranchesTElemCategoryHostName BranchesTElemCategory = "host_name"
const BranchesTElemCategoryLanguage BranchesTElemCategory = "language"
const BranchesTElemCategoryLegacy BranchesTElemCategory = "legacy"
const BranchesTElemCategoryPatchLevel BranchesTElemCategory = "patch_level"
const BranchesTElemCategoryProductFamily BranchesTElemCategory = "product_family"
const BranchesTElemCategoryProductName BranchesTElemCategory = "product_name"
const BranchesTElemCategoryProductVersion BranchesTElemCategory = "product_version"
const BranchesTElemCategoryProductVersionRange BranchesTElemCategory = "product_version_range"
const BranchesTElemCategoryServicePack BranchesTElemCategory = "service_pack"
const BranchesTElemCategorySpecification BranchesTElemCategory = "specification"
const BranchesTElemCategoryVendor BranchesTElemCategory = "vendor"

// Representation of security advisory information as a JSON document.
type CsafJson struct {
	// Captures the meta-data about this document describing a particular set of
	// security advisories.
	Document CsafJsonDocument `json:"document"`

	// Is a container for all fully qualified product names that can be referenced
	// elsewhere in the document.
	ProductTree *CsafJsonProductTree `json:"product_tree,omitempty"`

	// Represents a list of all relevant vulnerability information items.
	Vulnerabilities []CsafJsonVulnerabilitiesElem `json:"vulnerabilities,omitempty"`
}

// Captures the meta-data about this document describing a particular set of
// security advisories.
type CsafJsonDocument struct {
	// Contains a list of acknowledgment elements associated with the whole document.
	Acknowledgments AcknowledgmentsT `json:"acknowledgments,omitempty"`

	// Is a vehicle that is provided by the document producer to convey the urgency
	// and criticality with which the one or more vulnerabilities reported should be
	// addressed. It is a document-level metric and applied to the document as a whole
	// — not any specific vulnerability. The range of values in this field is
	// defined according to the document producer's policies and procedures.
	AggregateSeverity *CsafJsonDocumentAggregateSeverity `json:"aggregate_severity,omitempty"`

	// Defines a short canonical name, chosen by the document producer, which will
	// inform the end user as to the category of document.
	Category string `json:"category"`

	// Gives the version of the CSAF specification which the document was generated
	// for.
	CsafVersion CsafJsonDocumentCsafVersion `json:"csaf_version"`

	// Describe any constraints on how this document might be shared.
	Distribution *CsafJsonDocumentDistribution `json:"distribution,omitempty"`

	// Identifies the language used by this document, corresponding to IETF BCP 47 /
	// RFC 5646.
	Lang *LangT `json:"lang,omitempty"`

	// Holds notes associated with the whole document.
	Notes NotesT `json:"notes,omitempty"`

	// Provides information about the publisher of the document.
	Publisher CsafJsonDocumentPublisher `json:"publisher"`

	// Holds a list of references associated with the whole document.
	References ReferencesT `json:"references,omitempty"`

	// If this copy of the document is a translation then the value of this property
	// describes from which language this document was translated.
	SourceLang *LangT `json:"source_lang,omitempty"`

	// This SHOULD be a canonical name for the document, and sufficiently unique to
	// distinguish it from similar documents.
	Title string `json:"title"`

	// Is a container designated to hold all management attributes necessary to track
	// a CSAF document as a whole.
	Tracking CsafJsonDocumentTracking `json:"tracking"`
}

// Is a vehicle that is provided by the document producer to convey the urgency and
// criticality with which the one or more vulnerabilities reported should be
// addressed. It is a document-level metric and applied to the document as a whole
// — not any specific vulnerability. The range of values in this field is defined
// according to the document producer's policies and procedures.
type CsafJsonDocumentAggregateSeverity struct {
	// Points to the namespace so referenced.
	Namespace *string `json:"namespace,omitempty"`

	// Provides a severity which is independent of - and in addition to - any other
	// standard metric for determining the impact or severity of a given vulnerability
	// (such as CVSS).
	Text string `json:"text"`
}

type CsafJsonDocumentCsafVersion string

const CsafJsonDocumentCsafVersionA20 CsafJsonDocumentCsafVersion = "2.0"

// Describe any constraints on how this document might be shared.
type CsafJsonDocumentDistribution struct {
	// Provides a textual description of additional constraints.
	Text *string `json:"text,omitempty"`

	// Provides details about the TLP classification of the document.
	Tlp *CsafJsonDocumentDistributionTlp `json:"tlp,omitempty"`
}

// Provides details about the TLP classification of the document.
type CsafJsonDocumentDistributionTlp struct {
	// Provides the TLP label of the document.
	Label TLPLabel `json:"label"`

	// Provides a URL where to find the textual description of the TLP version which
	// is used in this document. Default is the URL to the definition by FIRST.
	Url string `json:"url,omitempty"`
}

// Provides information about the publisher of the document.
type CsafJsonDocumentPublisher struct {
	// Provides information about the category of publisher releasing the document.
	Category CsafJsonDocumentPublisherCategory `json:"category"`

	// Information on how to contact the publisher, possibly including details such as
	// web sites, email addresses, phone numbers, and postal mail addresses.
	ContactDetails *string `json:"contact_details,omitempty"`

	// Provides information about the authority of the issuing party to release the
	// document, in particular, the party's constituency and responsibilities or other
	// obligations.
	IssuingAuthority *string `json:"issuing_authority,omitempty"`

	// Contains the name of the issuing party.
	Name string `json:"name"`

	// Contains a URL which is under control of the issuing party and can be used as a
	// globally unique identifier for that issuing party.
	Namespace string `json:"namespace"`
}

type CsafJsonDocumentPublisherCategory string

const CsafJsonDocumentPublisherCategoryCoordinator CsafJsonDocumentPublisherCategory = "coordinator"
const CsafJsonDocumentPublisherCategoryDiscoverer CsafJsonDocumentPublisherCategory = "discoverer"
const CsafJsonDocumentPublisherCategoryOther CsafJsonDocumentPublisherCategory = "other"
const CsafJsonDocumentPublisherCategoryTranslator CsafJsonDocumentPublisherCategory = "translator"
const CsafJsonDocumentPublisherCategoryUser CsafJsonDocumentPublisherCategory = "user"
const CsafJsonDocumentPublisherCategoryVendor CsafJsonDocumentPublisherCategory = "vendor"

// Is a container designated to hold all management attributes necessary to track a
// CSAF document as a whole.
type CsafJsonDocumentTracking struct {
	// Contains a list of alternate names for the same document.
	Aliases []string `json:"aliases,omitempty"`

	// The date when the current revision of this document was released
	CurrentReleaseDate string `json:"current_release_date"`

	// Is a container to hold all elements related to the generation of the document.
	// These items will reference when the document was actually created, including
	// the date it was generated and the entity that generated it.
	Generator *CsafJsonDocumentTrackingGenerator `json:"generator,omitempty"`

	// The ID is a simple label that provides for a wide range of numbering values,
	// types, and schemes. Its value SHOULD be assigned and maintained by the original
	// document issuing authority.
	Id string `json:"id"`

	// The date when this document was first published.
	InitialReleaseDate string `json:"initial_release_date"`

	// Holds one revision item for each version of the CSAF document, including the
	// initial one.
	RevisionHistory []CsafJsonDocumentTrackingRevisionHistoryElem `json:"revision_history"`

	// Defines the draft status of the document.
	Status CsafJsonDocumentTrackingStatus `json:"status"`

	// Version corresponds to the JSON schema field "version".
	Version VersionT `json:"version"`
}

// Is a container to hold all elements related to the generation of the document.
// These items will reference when the document was actually created, including the
// date it was generated and the entity that generated it.
type CsafJsonDocumentTrackingGenerator struct {
	// This SHOULD be the current date that the document was generated. Because
	// documents are often generated internally by a document producer and exist for a
	// nonzero amount of time before being released, this field MAY be different from
	// the Initial Release Date and Current Release Date.
	Date *string `json:"date,omitempty"`

	// Contains information about the engine that generated the CSAF document.
	Engine CsafJsonDocumentTrackingGeneratorEngine `json:"engine"`
}

// Contains information about the engine that generated the CSAF document.
type CsafJsonDocumentTrackingGeneratorEngine struct {
	// Represents the name of the engine that generated the CSAF document.
	Name string `json:"name"`

	// Contains the version of the engine that generated the CSAF document.
	Version *string `json:"version,omitempty"`
}

// Contains all the information elements required to track the evolution of a CSAF
// document.
type CsafJsonDocumentTrackingRevisionHistoryElem struct {
	// The date of the revision entry
	Date string `json:"date"`

	// Contains the version string used in an existing document with the same content.
	LegacyVersion *string `json:"legacy_version,omitempty"`

	// Number corresponds to the JSON schema field "number".
	Number VersionT `json:"number"`

	// Holds a single non-empty string representing a short description of the
	// changes.
	Summary string `json:"summary"`
}

type CsafJsonDocumentTrackingStatus string

const CsafJsonDocumentTrackingStatusDraft CsafJsonDocumentTrackingStatus = "draft"
const CsafJsonDocumentTrackingStatusFinal CsafJsonDocumentTrackingStatus = "final"
const CsafJsonDocumentTrackingStatusInterim CsafJsonDocumentTrackingStatus = "interim"

// Is a container for all fully qualified product names that can be referenced
// elsewhere in the document.
type CsafJsonProductTree struct {
	// Branches corresponds to the JSON schema field "branches".
	Branches BranchesT `json:"branches,omitempty"`

	// Contains a list of full product names.
	FullProductNames []FullProductNameT `json:"full_product_names,omitempty"`

	// Contains a list of product groups.
	ProductGroups []CsafJsonProductTreeProductGroupsElem `json:"product_groups,omitempty"`

	// Contains a list of relationships.
	Relationships []CsafJsonProductTreeRelationshipsElem `json:"relationships,omitempty"`
}

// Defines a new logical group of products that can then be referred to in other
// parts of the document to address a group of products with a single identifier.
type CsafJsonProductTreeProductGroupsElem struct {
	// GroupId corresponds to the JSON schema field "group_id".
	GroupId ProductGroupIdT `json:"group_id"`

	// Lists the product_ids of those products which known as one group in the
	// document.
	ProductIds []ProductIdT `json:"product_ids"`

	// Gives a short, optional description of the group.
	Summary *string `json:"summary,omitempty"`
}

// Establishes a link between two existing full_product_name_t elements, allowing
// the document producer to define a combination of two products that form a new
// full_product_name entry.
type CsafJsonProductTreeRelationshipsElem struct {
	// Defines the category of relationship for the referenced component.
	Category CsafJsonProductTreeRelationshipsElemCategory `json:"category"`

	// FullProductName corresponds to the JSON schema field "full_product_name".
	FullProductName FullProductNameT `json:"full_product_name"`

	// Holds a Product ID that refers to the Full Product Name element, which is
	// referenced as the first element of the relationship.
	ProductReference ProductIdT `json:"product_reference"`

	// Holds a Product ID that refers to the Full Product Name element, which is
	// referenced as the second element of the relationship.
	RelatesToProductReference ProductIdT `json:"relates_to_product_reference"`
}

type CsafJsonProductTreeRelationshipsElemCategory string

const CsafJsonProductTreeRelationshipsElemCategoryDefaultComponentOf CsafJsonProductTreeRelationshipsElemCategory = "default_component_of"
const CsafJsonProductTreeRelationshipsElemCategoryExternalComponentOf CsafJsonProductTreeRelationshipsElemCategory = "external_component_of"
const CsafJsonProductTreeRelationshipsElemCategoryInstalledOn CsafJsonProductTreeRelationshipsElemCategory = "installed_on"
const CsafJsonProductTreeRelationshipsElemCategoryInstalledWith CsafJsonProductTreeRelationshipsElemCategory = "installed_with"
const CsafJsonProductTreeRelationshipsElemCategoryOptionalComponentOf CsafJsonProductTreeRelationshipsElemCategory = "optional_component_of"

// Is a container for the aggregation of all fields that are related to a single
// vulnerability in the document.
type CsafJsonVulnerabilitiesElem struct {
	// Contains a list of acknowledgment elements associated with this vulnerability
	// item.
	Acknowledgments AcknowledgmentsT `json:"acknowledgments,omitempty"`

	// Holds the MITRE standard Common Vulnerabilities and Exposures (CVE) tracking
	// number for the vulnerability.
	Cve *string `json:"cve,omitempty"`

	// Holds the MITRE standard Common Weakness Enumeration (CWE) for the weakness
	// associated.
	Cwe *CsafJsonVulnerabilitiesElemCwe `json:"cwe,omitempty"`

	// Holds the date and time the vulnerability was originally discovered.
	DiscoveryDate *string `json:"discovery_date,omitempty"`

	// Contains a list of machine readable flags.
	Flags []CsafJsonVulnerabilitiesElemFlagsElem `json:"flags,omitempty"`

	// Represents a list of unique labels or tracking IDs for the vulnerability (if
	// such information exists).
	Ids []CsafJsonVulnerabilitiesElemIdsElem `json:"ids,omitempty"`

	// Contains a list of involvements.
	Involvements []CsafJsonVulnerabilitiesElemInvolvementsElem `json:"involvements,omitempty"`

	// Holds notes associated with this vulnerability item.
	Notes NotesT `json:"notes,omitempty"`

	// Contains different lists of product_ids which provide details on the status of
	// the referenced product related to the current vulnerability.
	ProductStatus *CsafJsonVulnerabilitiesElemProductStatus `json:"product_status,omitempty"`

	// Holds a list of references associated with this vulnerability item.
	References ReferencesT `json:"references,omitempty"`

	// Holds the date and time the vulnerability was originally released into the
	// wild.
	ReleaseDate *string `json:"release_date,omitempty"`

	// Contains a list of remediations.
	Remediations []CsafJsonVulnerabilitiesElemRemediationsElem `json:"remediations,omitempty"`

	// contains score objects for the current vulnerability.
	Scores []CsafJsonVulnerabilitiesElemScoresElem `json:"scores,omitempty"`

	// Contains information about a vulnerability that can change with time.
	Threats []CsafJsonVulnerabilitiesElemThreatsElem `json:"threats,omitempty"`

	// Gives the document producer the ability to apply a canonical name or title to
	// the vulnerability.
	Title *string `json:"title,omitempty"`
}

// Holds the MITRE standard Common Weakness Enumeration (CWE) for the weakness
// associated.
type CsafJsonVulnerabilitiesElemCwe struct {
	// Holds the ID for the weakness associated.
	Id string `json:"id"`

	// Holds the full name of the weakness as given in the CWE specification.
	Name string `json:"name"`
}

// Contains product specific information in regard to this vulnerability as a
// single machine readable flag.
type CsafJsonVulnerabilitiesElemFlagsElem struct {
	// Contains the date when assessment was done or the flag was assigned.
	Date *string `json:"date,omitempty"`

	// GroupIds corresponds to the JSON schema field "group_ids".
	GroupIds ProductGroupsT `json:"group_ids,omitempty"`

	// Specifies the machine readable label.
	Label CsafJsonVulnerabilitiesElemFlagsElemLabel `json:"label"`

	// ProductIds corresponds to the JSON schema field "product_ids".
	ProductIds ProductsT `json:"product_ids,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CsafJsonDocumentCsafVersion) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CsafJsonDocumentCsafVersion {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CsafJsonDocumentCsafVersion, v)
	}
	*j = CsafJsonDocumentCsafVersion(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CsafJsonProductTreeRelationshipsElemCategory) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CsafJsonProductTreeRelationshipsElemCategory {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CsafJsonProductTreeRelationshipsElemCategory, v)
	}
	*j = CsafJsonProductTreeRelationshipsElemCategory(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CsafJsonDocumentAggregateSeverity) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["text"]; !ok || v == nil {
		return fmt.Errorf("field text: required")
	}
	type Plain CsafJsonDocumentAggregateSeverity
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CsafJsonDocumentAggregateSeverity(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ReferencesTElemCategory) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ReferencesTElemCategory {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ReferencesTElemCategory, v)
	}
	*j = ReferencesTElemCategory(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CsafJsonProductTreeRelationshipsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["category"]; !ok || v == nil {
		return fmt.Errorf("field category: required")
	}
	if v, ok := raw["full_product_name"]; !ok || v == nil {
		return fmt.Errorf("field full_product_name: required")
	}
	if v, ok := raw["product_reference"]; !ok || v == nil {
		return fmt.Errorf("field product_reference: required")
	}
	if v, ok := raw["relates_to_product_reference"]; !ok || v == nil {
		return fmt.Errorf("field relates_to_product_reference: required")
	}
	type Plain CsafJsonProductTreeRelationshipsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CsafJsonProductTreeRelationshipsElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CsafJsonVulnerabilitiesElemCwe) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	type Plain CsafJsonVulnerabilitiesElemCwe
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CsafJsonVulnerabilitiesElemCwe(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CsafJsonVulnerabilitiesElemFlagsElemLabel) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CsafJsonVulnerabilitiesElemFlagsElemLabel {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CsafJsonVulnerabilitiesElemFlagsElemLabel, v)
	}
	*j = CsafJsonVulnerabilitiesElemFlagsElemLabel(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CsafJsonDocumentDistributionTlp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["label"]; !ok || v == nil {
		return fmt.Errorf("field label: required")
	}
	type Plain CsafJsonDocumentDistributionTlp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["url"]; !ok || v == nil {
		plain.Url = "https://www.first.org/tlp/"
	}
	*j = CsafJsonDocumentDistributionTlp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CsafJsonVulnerabilitiesElemFlagsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["label"]; !ok || v == nil {
		return fmt.Errorf("field label: required")
	}
	type Plain CsafJsonVulnerabilitiesElemFlagsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CsafJsonVulnerabilitiesElemFlagsElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CsafJsonVulnerabilitiesElemIdsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["system_name"]; !ok || v == nil {
		return fmt.Errorf("field system_name: required")
	}
	if v, ok := raw["text"]; !ok || v == nil {
		return fmt.Errorf("field text: required")
	}
	type Plain CsafJsonVulnerabilitiesElemIdsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CsafJsonVulnerabilitiesElemIdsElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CsafJsonVulnerabilitiesElemInvolvementsElemParty) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CsafJsonVulnerabilitiesElemInvolvementsElemParty {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CsafJsonVulnerabilitiesElemInvolvementsElemParty, v)
	}
	*j = CsafJsonVulnerabilitiesElemInvolvementsElemParty(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CsafJsonDocumentPublisherCategory) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CsafJsonDocumentPublisherCategory {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CsafJsonDocumentPublisherCategory, v)
	}
	*j = CsafJsonDocumentPublisherCategory(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CsafJsonVulnerabilitiesElemInvolvementsElemStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CsafJsonVulnerabilitiesElemInvolvementsElemStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CsafJsonVulnerabilitiesElemInvolvementsElemStatus, v)
	}
	*j = CsafJsonVulnerabilitiesElemInvolvementsElemStatus(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NotesTElemCategory) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NotesTElemCategory {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NotesTElemCategory, v)
	}
	*j = NotesTElemCategory(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CsafJsonVulnerabilitiesElemInvolvementsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["party"]; !ok || v == nil {
		return fmt.Errorf("field party: required")
	}
	if v, ok := raw["status"]; !ok || v == nil {
		return fmt.Errorf("field status: required")
	}
	type Plain CsafJsonVulnerabilitiesElemInvolvementsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CsafJsonVulnerabilitiesElemInvolvementsElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CsafJsonVulnerabilitiesElemRemediationsElemCategory) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CsafJsonVulnerabilitiesElemRemediationsElemCategory {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CsafJsonVulnerabilitiesElemRemediationsElemCategory, v)
	}
	*j = CsafJsonVulnerabilitiesElemRemediationsElemCategory(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CsafJsonVulnerabilitiesElemRemediationsElemRestartRequiredCategory) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CsafJsonVulnerabilitiesElemRemediationsElemRestartRequiredCategory {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CsafJsonVulnerabilitiesElemRemediationsElemRestartRequiredCategory, v)
	}
	*j = CsafJsonVulnerabilitiesElemRemediationsElemRestartRequiredCategory(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FullProductNameT) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["product_id"]; !ok || v == nil {
		return fmt.Errorf("field product_id: required")
	}
	type Plain FullProductNameT
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = FullProductNameT(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CsafJsonVulnerabilitiesElemRemediationsElemRestartRequired) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["category"]; !ok || v == nil {
		return fmt.Errorf("field category: required")
	}
	type Plain CsafJsonVulnerabilitiesElemRemediationsElemRestartRequired
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CsafJsonVulnerabilitiesElemRemediationsElemRestartRequired(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CsafJsonDocumentPublisher) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["category"]; !ok || v == nil {
		return fmt.Errorf("field category: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["namespace"]; !ok || v == nil {
		return fmt.Errorf("field namespace: required")
	}
	type Plain CsafJsonDocumentPublisher
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CsafJsonDocumentPublisher(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CsafJsonVulnerabilitiesElemRemediationsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["category"]; !ok || v == nil {
		return fmt.Errorf("field category: required")
	}
	if v, ok := raw["details"]; !ok || v == nil {
		return fmt.Errorf("field details: required")
	}
	type Plain CsafJsonVulnerabilitiesElemRemediationsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CsafJsonVulnerabilitiesElemRemediationsElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CsafJsonDocumentTrackingGeneratorEngine) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	type Plain CsafJsonDocumentTrackingGeneratorEngine
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CsafJsonDocumentTrackingGeneratorEngine(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FullProductNameTProductIdentificationHelperXGenericUrisElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["namespace"]; !ok || v == nil {
		return fmt.Errorf("field namespace: required")
	}
	if v, ok := raw["uri"]; !ok || v == nil {
		return fmt.Errorf("field uri: required")
	}
	type Plain FullProductNameTProductIdentificationHelperXGenericUrisElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = FullProductNameTProductIdentificationHelperXGenericUrisElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CsafJsonDocumentTrackingGenerator) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["engine"]; !ok || v == nil {
		return fmt.Errorf("field engine: required")
	}
	type Plain CsafJsonDocumentTrackingGenerator
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CsafJsonDocumentTrackingGenerator(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CsafJsonVulnerabilitiesElemScoresElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["products"]; !ok || v == nil {
		return fmt.Errorf("field products: required")
	}
	type Plain CsafJsonVulnerabilitiesElemScoresElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CsafJsonVulnerabilitiesElemScoresElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CsafJsonDocumentTrackingRevisionHistoryElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["date"]; !ok || v == nil {
		return fmt.Errorf("field date: required")
	}
	if v, ok := raw["number"]; !ok || v == nil {
		return fmt.Errorf("field number: required")
	}
	if v, ok := raw["summary"]; !ok || v == nil {
		return fmt.Errorf("field summary: required")
	}
	type Plain CsafJsonDocumentTrackingRevisionHistoryElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CsafJsonDocumentTrackingRevisionHistoryElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FullProductNameTProductIdentificationHelperHashesElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["file_hashes"]; !ok || v == nil {
		return fmt.Errorf("field file_hashes: required")
	}
	if v, ok := raw["filename"]; !ok || v == nil {
		return fmt.Errorf("field filename: required")
	}
	type Plain FullProductNameTProductIdentificationHelperHashesElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = FullProductNameTProductIdentificationHelperHashesElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CsafJsonProductTreeProductGroupsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["group_id"]; !ok || v == nil {
		return fmt.Errorf("field group_id: required")
	}
	if v, ok := raw["product_ids"]; !ok || v == nil {
		return fmt.Errorf("field product_ids: required")
	}
	type Plain CsafJsonProductTreeProductGroupsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CsafJsonProductTreeProductGroupsElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CsafJsonDocumentTrackingStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CsafJsonDocumentTrackingStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CsafJsonDocumentTrackingStatus, v)
	}
	*j = CsafJsonDocumentTrackingStatus(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CsafJsonVulnerabilitiesElemThreatsElemCategory) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CsafJsonVulnerabilitiesElemThreatsElemCategory {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CsafJsonVulnerabilitiesElemThreatsElemCategory, v)
	}
	*j = CsafJsonVulnerabilitiesElemThreatsElemCategory(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FullProductNameTProductIdentificationHelperHashesElemFileHashesElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["value"]; !ok || v == nil {
		return fmt.Errorf("field value: required")
	}
	type Plain FullProductNameTProductIdentificationHelperHashesElemFileHashesElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["algorithm"]; !ok || v == nil {
		plain.Algorithm = "sha256"
	}
	*j = FullProductNameTProductIdentificationHelperHashesElemFileHashesElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CsafJsonVulnerabilitiesElemThreatsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["category"]; !ok || v == nil {
		return fmt.Errorf("field category: required")
	}
	if v, ok := raw["details"]; !ok || v == nil {
		return fmt.Errorf("field details: required")
	}
	type Plain CsafJsonVulnerabilitiesElemThreatsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CsafJsonVulnerabilitiesElemThreatsElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BranchesTElemCategory) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BranchesTElemCategory {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BranchesTElemCategory, v)
	}
	*j = BranchesTElemCategory(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CsafJsonDocumentTracking) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["current_release_date"]; !ok || v == nil {
		return fmt.Errorf("field current_release_date: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["initial_release_date"]; !ok || v == nil {
		return fmt.Errorf("field initial_release_date: required")
	}
	if v, ok := raw["revision_history"]; !ok || v == nil {
		return fmt.Errorf("field revision_history: required")
	}
	if v, ok := raw["status"]; !ok || v == nil {
		return fmt.Errorf("field status: required")
	}
	if v, ok := raw["version"]; !ok || v == nil {
		return fmt.Errorf("field version: required")
	}
	type Plain CsafJsonDocumentTracking
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CsafJsonDocumentTracking(plain)
	return nil
}

type CsafJsonVulnerabilitiesElemFlagsElemLabel string

// UnmarshalJSON implements json.Unmarshaler.
func (j *CsafJsonDocument) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["category"]; !ok || v == nil {
		return fmt.Errorf("field category: required")
	}
	if v, ok := raw["csaf_version"]; !ok || v == nil {
		return fmt.Errorf("field csaf_version: required")
	}
	if v, ok := raw["publisher"]; !ok || v == nil {
		return fmt.Errorf("field publisher: required")
	}
	if v, ok := raw["title"]; !ok || v == nil {
		return fmt.Errorf("field title: required")
	}
	if v, ok := raw["tracking"]; !ok || v == nil {
		return fmt.Errorf("field tracking: required")
	}
	type Plain CsafJsonDocument
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CsafJsonDocument(plain)
	return nil
}

const CsafJsonVulnerabilitiesElemFlagsElemLabelComponentNotPresent CsafJsonVulnerabilitiesElemFlagsElemLabel = "component_not_present"
const CsafJsonVulnerabilitiesElemFlagsElemLabelInlineMitigationsAlreadyExist CsafJsonVulnerabilitiesElemFlagsElemLabel = "inline_mitigations_already_exist"
const CsafJsonVulnerabilitiesElemFlagsElemLabelVulnerableCodeCannotBeControlledByAdversary CsafJsonVulnerabilitiesElemFlagsElemLabel = "vulnerable_code_cannot_be_controlled_by_adversary"
const CsafJsonVulnerabilitiesElemFlagsElemLabelVulnerableCodeNotInExecutePath CsafJsonVulnerabilitiesElemFlagsElemLabel = "vulnerable_code_not_in_execute_path"
const CsafJsonVulnerabilitiesElemFlagsElemLabelVulnerableCodeNotPresent CsafJsonVulnerabilitiesElemFlagsElemLabel = "vulnerable_code_not_present"

// Contains a single unique label or tracking ID for the vulnerability.
type CsafJsonVulnerabilitiesElemIdsElem struct {
	// Indicates the name of the vulnerability tracking or numbering system.
	SystemName string `json:"system_name"`

	// Is unique label or tracking ID for the vulnerability (if such information
	// exists).
	Text string `json:"text"`
}

// Is a container, that allows the document producers to comment on the level of
// involvement (or engagement) of themselves or third parties in the vulnerability
// identification, scoping, and remediation process.
type CsafJsonVulnerabilitiesElemInvolvementsElem struct {
	// Holds the date and time of the involvement entry.
	Date *string `json:"date,omitempty"`

	// Defines the category of the involved party.
	Party CsafJsonVulnerabilitiesElemInvolvementsElemParty `json:"party"`

	// Defines contact status of the involved party.
	Status CsafJsonVulnerabilitiesElemInvolvementsElemStatus `json:"status"`

	// Contains additional context regarding what is going on.
	Summary *string `json:"summary,omitempty"`
}

type CsafJsonVulnerabilitiesElemInvolvementsElemParty string

const CsafJsonVulnerabilitiesElemInvolvementsElemPartyCoordinator CsafJsonVulnerabilitiesElemInvolvementsElemParty = "coordinator"
const CsafJsonVulnerabilitiesElemInvolvementsElemPartyDiscoverer CsafJsonVulnerabilitiesElemInvolvementsElemParty = "discoverer"
const CsafJsonVulnerabilitiesElemInvolvementsElemPartyOther CsafJsonVulnerabilitiesElemInvolvementsElemParty = "other"
const CsafJsonVulnerabilitiesElemInvolvementsElemPartyUser CsafJsonVulnerabilitiesElemInvolvementsElemParty = "user"
const CsafJsonVulnerabilitiesElemInvolvementsElemPartyVendor CsafJsonVulnerabilitiesElemInvolvementsElemParty = "vendor"

type CsafJsonVulnerabilitiesElemInvolvementsElemStatus string

const CsafJsonVulnerabilitiesElemInvolvementsElemStatusCompleted CsafJsonVulnerabilitiesElemInvolvementsElemStatus = "completed"
const CsafJsonVulnerabilitiesElemInvolvementsElemStatusContactAttempted CsafJsonVulnerabilitiesElemInvolvementsElemStatus = "contact_attempted"
const CsafJsonVulnerabilitiesElemInvolvementsElemStatusDisputed CsafJsonVulnerabilitiesElemInvolvementsElemStatus = "disputed"
const CsafJsonVulnerabilitiesElemInvolvementsElemStatusInProgress CsafJsonVulnerabilitiesElemInvolvementsElemStatus = "in_progress"
const CsafJsonVulnerabilitiesElemInvolvementsElemStatusNotContacted CsafJsonVulnerabilitiesElemInvolvementsElemStatus = "not_contacted"
const CsafJsonVulnerabilitiesElemInvolvementsElemStatusOpen CsafJsonVulnerabilitiesElemInvolvementsElemStatus = "open"

// Contains different lists of product_ids which provide details on the status of
// the referenced product related to the current vulnerability.
type CsafJsonVulnerabilitiesElemProductStatus struct {
	// These are the first versions of the releases known to be affected by the
	// vulnerability.
	FirstAffected ProductsT `json:"first_affected,omitempty"`

	// These versions contain the first fix for the vulnerability but may not be the
	// recommended fixed versions.
	FirstFixed ProductsT `json:"first_fixed,omitempty"`

	// These versions contain a fix for the vulnerability but may not be the
	// recommended fixed versions.
	Fixed ProductsT `json:"fixed,omitempty"`

	// These versions are known to be affected by the vulnerability.
	KnownAffected ProductsT `json:"known_affected,omitempty"`

	// These versions are known not to be affected by the vulnerability.
	KnownNotAffected ProductsT `json:"known_not_affected,omitempty"`

	// These are the last versions in a release train known to be affected by the
	// vulnerability. Subsequently released versions would contain a fix for the
	// vulnerability.
	LastAffected ProductsT `json:"last_affected,omitempty"`

	// These versions have a fix for the vulnerability and are the vendor-recommended
	// versions for fixing the vulnerability.
	Recommended ProductsT `json:"recommended,omitempty"`

	// It is not known yet whether these versions are or are not affected by the
	// vulnerability. However, it is still under investigation - the result will be
	// provided in a later release of the document.
	UnderInvestigation ProductsT `json:"under_investigation,omitempty"`
}

// Specifies details on how to handle (and presumably, fix) a vulnerability.
type CsafJsonVulnerabilitiesElemRemediationsElem struct {
	// Specifies the category which this remediation belongs to.
	Category CsafJsonVulnerabilitiesElemRemediationsElemCategory `json:"category"`

	// Contains the date from which the remediation is available.
	Date *string `json:"date,omitempty"`

	// Contains a thorough human-readable discussion of the remediation.
	Details string `json:"details"`

	// Contains a list of entitlements.
	Entitlements []string `json:"entitlements,omitempty"`

	// GroupIds corresponds to the JSON schema field "group_ids".
	GroupIds ProductGroupsT `json:"group_ids,omitempty"`

	// ProductIds corresponds to the JSON schema field "product_ids".
	ProductIds ProductsT `json:"product_ids,omitempty"`

	// Provides information on category of restart is required by this remediation to
	// become effective.
	RestartRequired *CsafJsonVulnerabilitiesElemRemediationsElemRestartRequired `json:"restart_required,omitempty"`

	// Contains the URL where to obtain the remediation.
	Url *string `json:"url,omitempty"`
}

type CsafJsonVulnerabilitiesElemRemediationsElemCategory string

const CsafJsonVulnerabilitiesElemRemediationsElemCategoryMitigation CsafJsonVulnerabilitiesElemRemediationsElemCategory = "mitigation"
const CsafJsonVulnerabilitiesElemRemediationsElemCategoryNoFixPlanned CsafJsonVulnerabilitiesElemRemediationsElemCategory = "no_fix_planned"
const CsafJsonVulnerabilitiesElemRemediationsElemCategoryNoneAvailable CsafJsonVulnerabilitiesElemRemediationsElemCategory = "none_available"
const CsafJsonVulnerabilitiesElemRemediationsElemCategoryVendorFix CsafJsonVulnerabilitiesElemRemediationsElemCategory = "vendor_fix"
const CsafJsonVulnerabilitiesElemRemediationsElemCategoryWorkaround CsafJsonVulnerabilitiesElemRemediationsElemCategory = "workaround"

// Provides information on category of restart is required by this remediation to
// become effective.
type CsafJsonVulnerabilitiesElemRemediationsElemRestartRequired struct {
	// Specifies what category of restart is required by this remediation to become
	// effective.
	Category CsafJsonVulnerabilitiesElemRemediationsElemRestartRequiredCategory `json:"category"`

	// Provides additional information for the restart. This can include details on
	// procedures, scope or impact.
	Details *string `json:"details,omitempty"`
}

type CsafJsonVulnerabilitiesElemRemediationsElemRestartRequiredCategory string

const CsafJsonVulnerabilitiesElemRemediationsElemRestartRequiredCategoryConnected CsafJsonVulnerabilitiesElemRemediationsElemRestartRequiredCategory = "connected"
const CsafJsonVulnerabilitiesElemRemediationsElemRestartRequiredCategoryDependencies CsafJsonVulnerabilitiesElemRemediationsElemRestartRequiredCategory = "dependencies"
const CsafJsonVulnerabilitiesElemRemediationsElemRestartRequiredCategoryMachine CsafJsonVulnerabilitiesElemRemediationsElemRestartRequiredCategory = "machine"
const CsafJsonVulnerabilitiesElemRemediationsElemRestartRequiredCategoryNone CsafJsonVulnerabilitiesElemRemediationsElemRestartRequiredCategory = "none"
const CsafJsonVulnerabilitiesElemRemediationsElemRestartRequiredCategoryParent CsafJsonVulnerabilitiesElemRemediationsElemRestartRequiredCategory = "parent"
const CsafJsonVulnerabilitiesElemRemediationsElemRestartRequiredCategoryService CsafJsonVulnerabilitiesElemRemediationsElemRestartRequiredCategory = "service"
const CsafJsonVulnerabilitiesElemRemediationsElemRestartRequiredCategorySystem CsafJsonVulnerabilitiesElemRemediationsElemRestartRequiredCategory = "system"
const CsafJsonVulnerabilitiesElemRemediationsElemRestartRequiredCategoryVulnerableComponent CsafJsonVulnerabilitiesElemRemediationsElemRestartRequiredCategory = "vulnerable_component"
const CsafJsonVulnerabilitiesElemRemediationsElemRestartRequiredCategoryZone CsafJsonVulnerabilitiesElemRemediationsElemRestartRequiredCategory = "zone"

// specifies information about (at least one) score of the vulnerability and for
// which products the given value applies.
type CsafJsonVulnerabilitiesElemScoresElem struct {
	// CvssV2 corresponds to the JSON schema field "cvss_v2".
	CvssV2 interface{} `json:"cvss_v2,omitempty"`

	// CvssV3 corresponds to the JSON schema field "cvss_v3".
	CvssV3 interface{} `json:"cvss_v3,omitempty"`

	// Products corresponds to the JSON schema field "products".
	Products interface{} `json:"products"`
}

// Contains the vulnerability kinetic information. This information can change as
// the vulnerability ages and new information becomes available.
type CsafJsonVulnerabilitiesElemThreatsElem struct {
	// Categorizes the threat according to the rules of the specification.
	Category CsafJsonVulnerabilitiesElemThreatsElemCategory `json:"category"`

	// Contains the date when the assessment was done or the threat appeared.
	Date *string `json:"date,omitempty"`

	// Represents a thorough human-readable discussion of the threat.
	Details string `json:"details"`

	// GroupIds corresponds to the JSON schema field "group_ids".
	GroupIds ProductGroupsT `json:"group_ids,omitempty"`

	// ProductIds corresponds to the JSON schema field "product_ids".
	ProductIds ProductsT `json:"product_ids,omitempty"`
}

type CsafJsonVulnerabilitiesElemThreatsElemCategory string

const CsafJsonVulnerabilitiesElemThreatsElemCategoryExploitStatus CsafJsonVulnerabilitiesElemThreatsElemCategory = "exploit_status"
const CsafJsonVulnerabilitiesElemThreatsElemCategoryImpact CsafJsonVulnerabilitiesElemThreatsElemCategory = "impact"
const CsafJsonVulnerabilitiesElemThreatsElemCategoryTargetSet CsafJsonVulnerabilitiesElemThreatsElemCategory = "target_set"

// Specifies information about the product and assigns the product_id.
type FullProductNameT struct {
	// The value should be the product’s full canonical name, including version
	// number and other attributes, as it would be used in a human-friendly document.
	Name string `json:"name"`

	// ProductId corresponds to the JSON schema field "product_id".
	ProductId ProductIdT `json:"product_id"`

	// Provides at least one method which aids in identifying the product in an asset
	// database.
	ProductIdentificationHelper *FullProductNameTProductIdentificationHelper `json:"product_identification_helper,omitempty"`
}

// Provides at least one method which aids in identifying the product in an asset
// database.
type FullProductNameTProductIdentificationHelper struct {
	// The Common Platform Enumeration (CPE) attribute refers to a method for naming
	// platforms external to this specification.
	Cpe *string `json:"cpe,omitempty"`

	// Contains a list of cryptographic hashes usable to identify files.
	Hashes []FullProductNameTProductIdentificationHelperHashesElem `json:"hashes,omitempty"`

	// Contains a list of parts, or full model numbers.
	ModelNumbers []string `json:"model_numbers,omitempty"`

	// The package URL (purl) attribute refers to a method for reliably identifying
	// and locating software packages external to this specification.
	Purl *string `json:"purl,omitempty"`

	// Contains a list of URLs where SBOMs for this product can be retrieved.
	SbomUrls []string `json:"sbom_urls,omitempty"`

	// Contains a list of parts, or full serial numbers.
	SerialNumbers []string `json:"serial_numbers,omitempty"`

	// Contains a list of parts, or full stock keeping units.
	Skus []string `json:"skus,omitempty"`

	// Contains a list of identifiers which are either vendor-specific or derived from
	// a standard not yet supported.
	XGenericUris []FullProductNameTProductIdentificationHelperXGenericUrisElem `json:"x_generic_uris,omitempty"`
}

// Contains all information to identify a file based on its cryptographic hash
// values.
type FullProductNameTProductIdentificationHelperHashesElem struct {
	// Contains a list of cryptographic hashes for this file.
	FileHashes []FullProductNameTProductIdentificationHelperHashesElemFileHashesElem `json:"file_hashes"`

	// Contains the name of the file which is identified by the hash values.
	Filename string `json:"filename"`
}

// Contains one hash value and algorithm of the file to be identified.
type FullProductNameTProductIdentificationHelperHashesElemFileHashesElem struct {
	// Contains the name of the cryptographic hash algorithm used to calculate the
	// value.
	Algorithm string `json:"algorithm"`

	// Contains the cryptographic hash value in hexadecimal representation.
	Value string `json:"value"`
}

// Provides a generic extension point for any identifier which is either
// vendor-specific or derived from a standard not yet supported.
type FullProductNameTProductIdentificationHelperXGenericUrisElem struct {
	// Refers to a URL which provides the name and knowledge about the specification
	// used or is the namespace in which these values are valid.
	Namespace string `json:"namespace"`

	// Contains the identifier itself.
	Uri string `json:"uri"`
}

// Identifies a language, corresponding to IETF BCP 47 / RFC 5646. See IETF
// language registry:
// https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry
type LangT string

// Contains notes which are specific to the current context.
type NotesT []struct {
	// Indicate who is intended to read it.
	Audience *string `json:"audience,omitempty"`

	// Choice of what kind of note this is.
	Category NotesTElemCategory `json:"category"`

	// The contents of the note. Content varies depending on type.
	Text string `json:"text"`

	// Provides a concise description of what is contained in the text of the note.
	Title *string `json:"title,omitempty"`
}

type NotesTElemCategory string

const NotesTElemCategoryDescription NotesTElemCategory = "description"
const NotesTElemCategoryDetails NotesTElemCategory = "details"
const NotesTElemCategoryFaq NotesTElemCategory = "faq"
const NotesTElemCategoryGeneral NotesTElemCategory = "general"
const NotesTElemCategoryLegalDisclaimer NotesTElemCategory = "legal_disclaimer"
const NotesTElemCategoryOther NotesTElemCategory = "other"
const NotesTElemCategorySummary NotesTElemCategory = "summary"

// Token required to identify a group of products so that it can be referred to
// from other parts in the document. There is no predefined or required format for
// the product_group_id as long as it uniquely identifies a group in the context of
// the current document.
type ProductGroupIdT string

// Specifies a list of product_group_ids to give context to the parent item.
type ProductGroupsT []ProductGroupIdT

// Token required to identify a full_product_name so that it can be referred to
// from other parts in the document. There is no predefined or required format for
// the product_id as long as it uniquely identifies a product in the context of the
// current document.
type ProductIdT string

// Specifies a list of product_ids to give context to the parent item.
type ProductsT []ProductIdT

// Holds a list of references.
type ReferencesT []struct {
	// Indicates whether the reference points to the same document or vulnerability in
	// focus (depending on scope) or to an external resource.
	Category ReferencesTElemCategory `json:"category,omitempty"`

	// Indicates what this reference refers to.
	Summary string `json:"summary"`

	// Provides the URL for the reference.
	Url string `json:"url"`
}

type ReferencesTElemCategory string

const ReferencesTElemCategoryExternal ReferencesTElemCategory = "external"
const ReferencesTElemCategorySelf ReferencesTElemCategory = "self"

// Specifies a version string to denote clearly the evolution of the content of the
// document. Format must be either integer or semantic versioning.
type VersionT string

var enumValues_BranchesTElemCategory = []interface{}{
	"architecture",
	"host_name",
	"language",
	"legacy",
	"patch_level",
	"product_family",
	"product_name",
	"product_version",
	"product_version_range",
	"service_pack",
	"specification",
	"vendor",
}
var enumValues_CsafJsonDocumentCsafVersion = []interface{}{
	"2.0",
}
var enumValues_CsafJsonDocumentDistributionTlpLabel = []interface{}{
	"AMBER",
	"GREEN",
	"RED",
	"WHITE",
}
var enumValues_CsafJsonDocumentPublisherCategory = []interface{}{
	"coordinator",
	"discoverer",
	"other",
	"translator",
	"user",
	"vendor",
}
var enumValues_CsafJsonDocumentTrackingStatus = []interface{}{
	"draft",
	"final",
	"interim",
}
var enumValues_CsafJsonProductTreeRelationshipsElemCategory = []interface{}{
	"default_component_of",
	"external_component_of",
	"installed_on",
	"installed_with",
	"optional_component_of",
}
var enumValues_CsafJsonVulnerabilitiesElemFlagsElemLabel = []interface{}{
	"component_not_present",
	"inline_mitigations_already_exist",
	"vulnerable_code_cannot_be_controlled_by_adversary",
	"vulnerable_code_not_in_execute_path",
	"vulnerable_code_not_present",
}
var enumValues_CsafJsonVulnerabilitiesElemInvolvementsElemParty = []interface{}{
	"coordinator",
	"discoverer",
	"other",
	"user",
	"vendor",
}
var enumValues_CsafJsonVulnerabilitiesElemInvolvementsElemStatus = []interface{}{
	"completed",
	"contact_attempted",
	"disputed",
	"in_progress",
	"not_contacted",
	"open",
}
var enumValues_CsafJsonVulnerabilitiesElemRemediationsElemCategory = []interface{}{
	"mitigation",
	"no_fix_planned",
	"none_available",
	"vendor_fix",
	"workaround",
}
var enumValues_CsafJsonVulnerabilitiesElemRemediationsElemRestartRequiredCategory = []interface{}{
	"connected",
	"dependencies",
	"machine",
	"none",
	"parent",
	"service",
	"system",
	"vulnerable_component",
	"zone",
}
var enumValues_CsafJsonVulnerabilitiesElemThreatsElemCategory = []interface{}{
	"exploit_status",
	"impact",
	"target_set",
}
var enumValues_NotesTElemCategory = []interface{}{
	"description",
	"details",
	"faq",
	"general",
	"legal_disclaimer",
	"other",
	"summary",
}
var enumValues_ReferencesTElemCategory = []interface{}{
	"external",
	"self",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CsafJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["document"]; !ok || v == nil {
		return fmt.Errorf("field document: required")
	}
	type Plain CsafJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CsafJson(plain)
	return nil
}